--- a/Factor.h
+++ b/Factor.h
@@ -48,6 +48,8 @@
 
     void syncAdjBeliefsFromVariables();
     void computeFactor(const Eigen::VectorXd& linpoint, bool update_self = true);
+    // Jacobian/Lambda cache control (use when structure changes)
+    void invalidateJacobianCache();
     void computeMessages(double eta_damping);
 
 private:
@@ -99,6 +101,16 @@
     Eigen::VectorXd tmpv_cf_;    // tmp vector: Oi * ri (m)
     Eigen::MatrixXd tmpm_cf_;    // tmp matrix: Oi * Ji (m x D)
 
+
+    // ==========================
+    // Jacobian / Lambda cache (J assumed constant across iterations)
+    // ==========================
+    bool jcache_valid_ = false;   // whether J/JO/Lambda cache is valid
+    bool lamcache_set_ = false;   // whether factor.lam has been set from cache
+    std::vector<Eigen::MatrixXd> J_cache_;   // blocks Ji (m x D)
+    std::vector<Eigen::MatrixXd> JO_cache_;  // blocks (Ji^T * Oi) (D x m)
+    Eigen::MatrixXd lambda_cache_;           // sum_i (Ji^T * Oi * Ji) (D x D)
+
     // Outputs (allocated once)
     Eigen::VectorXd new_eta_[2]; // size: d0_ / d1_
     Eigen::MatrixXd new_lam_[2]; // size: d0_xd0 / d1_xd1
--- a/Factor.cpp
+++ b/Factor.cpp
@@ -159,39 +159,86 @@
     }
 }
 
+void Factor::invalidateJacobianCache() {
+    jcache_valid_ = false;
+    lamcache_set_ = false;
+    J_cache_.clear();
+    JO_cache_.clear();
+    lambda_cache_.resize(0, 0);
+}
+
 void Factor::computeFactor(const Eigen::VectorXd& linpoint_in, bool update_self) {
     ++g_cf_call_count;
 
     linpoint = linpoint_in;
 
+    // meas_fn may depend on current linpoint (e.g. via k), so we evaluate it every call.
     auto t0 = std::chrono::high_resolution_clock::now();
-    auto J    = jac_fn(linpoint);
+    auto pred = meas_fn(linpoint);
     auto t1 = std::chrono::high_resolution_clock::now();
-    g_cf_jac_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t1 - t0).count();
-
-    auto pred = meas_fn(linpoint);
+    g_cf_meas_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t1 - t0).count();
+
+    const int D = (int)linpoint.size();
+
+    // Build Jacobian-derived caches lazily (assumes J and measurement_lambda do not change
+    // across iterations for the current graph / abstraction).
+    if (!jcache_valid_) {
+        auto tJ0 = std::chrono::high_resolution_clock::now();
+        auto J = jac_fn(linpoint);
+        auto tJ1 = std::chrono::high_resolution_clock::now();
+        g_cf_jac_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(tJ1 - tJ0).count();
+
+        if (J.size() != measurement.size() ||
+            J.size() != measurement_lambda.size() ||
+            J.size() != pred.size()) {
+            throw std::runtime_error("computeFactor: block list size mismatch among J, measurement, measurement_lambda, pred");
+        }
+
+        // Cache J blocks (move) and precompute JO = J^T * O, and Lambda = sum JO * J.
+        J_cache_ = std::move(J);
+        JO_cache_.resize(J_cache_.size());
+
+        lambda_cache_.resize(D, D);
+        lambda_cache_.setZero();
+
+        for (size_t i = 0; i < J_cache_.size(); ++i) {
+            const Eigen::MatrixXd& Ji = J_cache_[i];
+            const Eigen::MatrixXd& Oi = measurement_lambda[i];
+
+            // JO_i = Ji^T * Oi   (D x m)
+            JO_cache_[i].resize(Ji.cols(), Oi.cols());
+            JO_cache_[i].noalias() = Ji.transpose() * Oi;
+
+            // Lambda += JO_i * Ji   (D x m) * (m x D) -> (D x D)
+            lambda_cache_.noalias() += JO_cache_[i] * Ji;
+        }
+
+        jcache_valid_ = true;
+        lamcache_set_ = false; // ensure we push cached lambda to factor once
+    } else {
+        // Validate sizes in cached mode (cheap safety).
+        if (J_cache_.size() != measurement.size() ||
+            J_cache_.size() != measurement_lambda.size() ||
+            J_cache_.size() != pred.size()) {
+            throw std::runtime_error("computeFactor(cached): block list size mismatch among cached J, measurement, measurement_lambda, pred");
+        }
+        // Dimension may change only if graph structure changed; force rebuild in that case.
+        if (lambda_cache_.rows() != D || lambda_cache_.cols() != D) {
+            // Conservative: rebuild cache.
+            jcache_valid_ = false;
+            computeFactor(linpoint_in, update_self);
+            return;
+        }
+    }
+
+    // Compute eta only (Lambda is cached and constant).
+    eta_f_.resize(D);
+    eta_f_.setZero();
+
     auto t2 = std::chrono::high_resolution_clock::now();
-    g_cf_meas_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count();
-
-    if (J.size() != measurement.size() ||
-        J.size() != measurement_lambda.size() ||
-        J.size() != pred.size()) {
-        throw std::runtime_error("computeFactor: block list size mismatch among J, measurement, measurement_lambda, pred");
-    }
-
-    const int D = (int)linpoint.size();
-
-    // Reuse preallocated scratch (eta_f_/lam_f_) to avoid per-call heap allocations.
-    lam_f_.resize(D, D);
-    eta_f_.resize(D);
-    lam_f_.setZero();
-    eta_f_.setZero();
-
-    auto t3 = std::chrono::high_resolution_clock::now();
-
-    for (size_t i = 0; i < J.size(); ++i) {
-        const Eigen::MatrixXd& Ji = J[i];
-        const Eigen::MatrixXd& Oi = measurement_lambda[i];
+
+    for (size_t i = 0; i < J_cache_.size(); ++i) {
+        const Eigen::MatrixXd& Ji = J_cache_[i];
         const Eigen::VectorXd& zi = measurement[i];
         const Eigen::VectorXd& hi = pred[i];
 
@@ -201,34 +248,23 @@
         ri_cf_.noalias() += zi;
         ri_cf_.noalias() -= hi;
 
-        // tmpm = Oi * Ji   (m x D)
-        tmpm_cf_.resize(Oi.rows(), Ji.cols());
-        tmpm_cf_.noalias() = Oi * Ji;
-
-        // lambda += Ji^T * tmpm   (D x m) * (m x D) -> (D x D)
-        lam_f_.noalias() += Ji.transpose() * tmpm_cf_;
-
-        auto t_lam = std::chrono::high_resolution_clock::now();
-        g_cf_loop_lam_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t_lam - t3).count();
-        t3 = t_lam;
-
-        // tmpv = Oi * ri   (m)
-        tmpv_cf_.resize(Oi.rows());
-        tmpv_cf_.noalias() = Oi * ri_cf_;
-
-        // eta += Ji^T * tmpv   (D x m) * (m) -> (D)
-        eta_f_.noalias() += Ji.transpose() * tmpv_cf_;
+        // eta += (Ji^T * Oi) * ri  == JO_i * ri
+        eta_f_.noalias() += JO_cache_[i] * ri_cf_;
 
         auto t_eta = std::chrono::high_resolution_clock::now();
-        g_cf_loop_eta_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t_eta - t3).count();
-        t3 = t_eta;
+        g_cf_loop_eta_ns += std::chrono::duration_cast<std::chrono::nanoseconds>(t_eta - t2).count();
+        t2 = t_eta;
     }
 
     if (update_self) {
-        factor.setLam(lam_f_);
+        if (!lamcache_set_) {
+            factor.setLam(lambda_cache_);
+            lamcache_set_ = true;
+        }
         factor.setEta(eta_f_);
     }
 }
+
 
 // ==============================
 // computeMessages (no resize path)
